package ro.app.banking.security.jwt;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;

import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Value;

import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.Map;

import javax.crypto.SecretKey;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class JwtService { //creates/verifies and extracts info(claims) from jwt
    private final SecretKey key; //this one signs and verifies sign for jwt
    private final long expirationMs; //jwt works w milliseconds
    private final long tempExpirationMs;
    private final String issuer; 

    private static final Logger log = LoggerFactory.getLogger(JwtService.class);

    public JwtService(
        @Value("${app.jwt.secret}") String secret,
        @Value("${app.jwt.expiration-minutes}") long expirationMs,
        @Value("${app.jwt.temp-expiration-minutes}") long tempExpirationMs,
        @Value("${app.jwt.issuer}") String issuer
    ){
        // resulting Key obj is stored in the service's internal this.key = used to digitally sign/verify all JWTs generated by this service
        this.key= Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8)); //config string secret is converted into a byte arr using UTF-8 char encoding
        this.expirationMs= expirationMs * 60_000;
        this.tempExpirationMs= tempExpirationMs * 60_000;
        this.issuer= issuer;
    }

    public String generateToken(String subject, Map<String, Object> claims){ //subject= name/email of user, claims= extra (role etc)
        return buildToken(subject, claims , expirationMs);
    }
    
    public String generateTempToken(String subject, Map<String, Object> claims){ //creates temp jwt with tempExpirationMs ; !no access to resources
        return buildToken(subject, claims, tempExpirationMs);
    }

    private String buildToken(String subject, Map<String, Object> claims, long ttlMs) { 
        if(subject ==null || subject.isBlank()){
            throw new IllegalArgumentException("JWT subject cannot be null or blank");
        }

        if(issuer ==null){
            throw new IllegalStateException("JWT issuer is not configured");
        }

        if(ttlMs <=0){
            throw new IllegalArgumentException("JWT ttl must be positive");
        }

        final Map<String, Object> safeClaims=
            (claims != null) ? claims : java.util.Collections.emptyMap();
        
        Date now = new Date();
        Date exp= new Date(now.getTime() + ttlMs);

        return Jwts.builder()
                    .issuer(issuer)
                    .subject(subject)
                    .claims(safeClaims)
                    .issuedAt(now)
                    .expiration(exp)
                    .signWith(key, Jwts.SIG.HS256)
                    .compact(); //compact makes it string
    }

    public Claims parseClaims(String token){
        if (token == null || token.isBlank()) {
            throw new IllegalArgumentException("JWT token is null or blank");
        }

        return Jwts.parser()
                    .verifyWith(key)
                    .build()
                    .parseSignedClaims(token)
                    .getPayload();
    }

    public boolean isValid(String token){
        try{
            parseClaims(token);
            return true;
        }catch(JwtException | IllegalArgumentException e){
            log.debug("Invalid JWT: {}", e.getMessage());
            return false;
        }
    }
}
